<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js中数组操作相关方法</title>
      <link href="/2020/04/07/js-zhong-shu-zu-fang-fa/"/>
      <url>/2020/04/07/js-zhong-shu-zu-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="js常见数组方法："><a href="#js常见数组方法：" class="headerlink" title="js常见数组方法："></a>js常见数组方法：</h2><ol><li><p><strong>join()就是把数组转换成字符串，然后给他规定个连接字符，默认不传参的是逗号,返回一个字符串</strong></p><pre><code>var arr = [1,2,3];console.log(arr.join()); 　　　　// 1,2,3console.log(arr.join(&quot;-&quot;)); 　　// 1-2-3console.log(arr); 　　　　　　　　// [1, 2, 3]（原数组不变）</code></pre></li><li><p><strong>push()和pop(),push():  把里面的内容添加到数组末尾，并返回修改后的长度。pop()：移除数组最后一项，返回移除的那个值，减少数组的length.</strong></p><pre><code>var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];var count = arr.push(&quot;Jack&quot;,&quot;Sean&quot;);console.log(count); 　　　　　　　　　　// 5console.log(arr); 　　　　　　　　　　　// [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Sean&quot;]var item = arr.pop();console.log(item); 　　　　　　　　　　 // Seanconsole.log(arr); 　　　　　　　　　　  // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;]</code></pre></li><li><p><strong>shift() 和 unshift()   (和上面的push，pop相反，针对第一项内容);  shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。unshift():将参数添加到原数组开头，并返回数组的长度 。</strong></p><pre><code>var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];var count = arr.unshift(&quot;Jack&quot;,&quot;Sean&quot;);console.log(count); 　　　　　　　　　　　　　　// 5console.log(arr); 　　　　　　　　　　　　　　　//[&quot;Jack&quot;, &quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]var item = arr.shift();console.log(item); 　　　　　　　　　　　　　　// Jackconsole.log(arr); 　　　　　　　　　　　　　　 // [&quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]</code></pre></li><li><p><strong>sort()：将数组里的项从小到大排序,sort()方法比较的是字符串，没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数;这个方法会直接改变原数组的排序顺序。</strong></p><pre><code>function sortNumber(a,b){　　return a - b}arr = [13, 24, 51, 3]; console.log(arr.sort()); 　　　　　　　　　　// [13, 24, 3, 51] console.log(arr.sort(sortNumber)); 　　　　// [3, 13, 24, 51](数组被改变)</code></pre></li><li><p><strong>reverse()：反转数组项的顺序. 反数组会发生改变</strong></p><pre><code>var arr = [13, 24, 51, 3];console.log(arr.reverse()); 　　　　　　　　//[3, 51, 24, 13]console.log(arr); 　　　　　　　　　　　　　　//[3, 51, 24, 13](原数组改变)</code></pre></li><li><p><strong>concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</strong></p><pre><code>var arr = [1,3,5,7];var arrCopy = arr.concat(9,[11,13]);console.log(arrCopy); 　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11, 13]console.log(arr); 　　　　　　　　　　　　　　// [1, 3, 5, 7](原数组未被修改)</code></pre></li><li><p><strong>slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。原数组不会发生改变,会返回一个满足条件的新数组</strong></p><pre><code>var arr = [1,3,5,7,9,11];var arrCopy = arr.slice(1);var arrCopy2 = arr.slice(1,4);var arrCopy3 = arr.slice(1,-2);var arrCopy4 = arr.slice(-4,-1);  //当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从2开始到5（不包括）的子数组。 console.log(arr); 　　　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11](原数组没变)console.log(arrCopy); 　　　　　　　　　　　 //[3, 5, 7, 9, 11]console.log(arrCopy2); 　　　　　　　　　　　//[3, 5, 7]console.log(arrCopy3); 　　　　　　　　　　　//[3, 5, 7]console.log(arrCopy4); 　　　　　　　　　　　//[5, 7, 9]</code></pre></li><li><p><strong>splice()：删除、插入和替换。这个方法十分强大，是对原数组进行改动</strong></p><pre><code>var arr = [1,3,5,7,9,11];var arrRemoved = arr.splice(0,2); //删除：指定 2 个参数：要删除元素的下标的位置和要删除的项数。console.log(arr); 　　　　　　　　　　　　　　　//[5, 7, 9, 11]console.log(arrRemoved); 　　　　　　　　　　　//[1, 3]var arrRemoved2 = arr.splice(2,0,4,6); //插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项,后面4,6就是要插入的两项。console.log(arr); 　　　　　　　　　　　　　　　// [5, 7, 4, 6, 9, 11]console.log(arrRemoved2); 　　　　　　　　　　// []var arrRemoved3 = arr.splice(1,1,2,4); //替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。console.log(arr); 　　　　　　　　　　　　　　　// [5, 2, 4, 4, 6, 9, 11]console.log(arrRemoved3); 　　　　　　　　　　//[7]</code></pre></li><li><p><strong>indexOf()和 lastIndexOf()；indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。默认从数组的开头（位置 0）开始向后查找。lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。默认从数组的末尾开始向前查找。</strong></p><pre><code>var arr = [1,3,5,7,7,5,3,1];console.log(arr.indexOf(5)); 　　　　　　//2console.log(arr.lastIndexOf(5)); 　　　 //5console.log(arr.indexOf(5,2)); 　　　　 //2console.log(arr.lastIndexOf(5,4)); 　　//2console.log(arr.indexOf(&quot;5&quot;)); 　　　　 //-1</code></pre></li><li><p><strong>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组item；元素对应的数组索引，数组本身。</strong></p><pre><code>var arr = [1, 2, 3, 4, 5];arr.forEach(function(item, index, a){ //item代表遍历这个数组里面的每一项,index是下表索引,a是这个被遍历的数组本身console.log(item + &#39;|&#39; + index + &#39;|&#39; + (a === arr));});// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true</code></pre></li><li><p><strong>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</strong></p><pre><code>var arr = [1, 2, 3, 4, 5];var arr2 = arr.every(function(item) {return item &lt; 10;}); console.log(arr2); 　　　　　　　　//truevar arr3 = arr.every(function(item) {return item &lt; 3;}); console.log(arr3); 　　　　　　　　// false</code></pre></li><li><p><strong>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</strong></p><pre><code>var arr = [1, 2, 3, 4, 5];var arr2 = arr.some(function(item) {return item &lt; 3;}); console.log(arr2); 　　　　　　　　//truevar arr3 = arr.some(function(item) {return item &lt; 1;}); console.log(arr3); 　　　　　　　　// false</code></pre></li><li><p><strong>map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</strong></p><pre><code>var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item){return item*item;});console.log(arr2); 　　　　　　　　//[1, 4, 9, 16, 25]</code></pre></li><li><p><strong>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</strong></p><pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var arr2 = arr.filter(function(item, index) {return index % 3 === 0 || item &gt;= 8; //只有为true才会返回当前项，最后组成一个新数组返回}); console.log(arr2); 　　　　　　　　//[1, 4, 7, 8, 9, 10]</code></pre></li><li><p><strong>reduce():”汇总”方法,参数是一个函数，函数里默认有4个参数可用;init 表示初始值。index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0开始，否则索引为1开始；cur 表示当前正在处理的数组元素；prev 表示上一次调用回调时的返回值，或者初始值 init;常用的参数只有两个：prev 和 cur。</strong></p><pre><code>//计算数组中每个元素出现的次数let names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Tiff&#39;, &#39;Bruce&#39;, &#39;Alice&#39;];let nameNum = names.reduce((prev,cur)=&gt;{ if(cur in prev){   pre[cur]++ }else{   pre[cur] = 1  } return prev},{})console.log(nameNum); //{Alice: 2, Bob: 1, Tiff: 1, Bruce: 1}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中字符串操作相关方法</title>
      <link href="/2020/04/07/js-de-zi-fu-chuan-fang-fa/"/>
      <url>/2020/04/07/js-de-zi-fu-chuan-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="JS字符串常用方法总结："><a href="#JS字符串常用方法总结：" class="headerlink" title="JS字符串常用方法总结："></a>JS字符串常用方法总结：</h2><ol><li><p><strong>toLowerCase(): 把字符串转为小写，返回新的字符串。</strong></p><pre><code>var str=&quot;Hello World&quot;;var str1=str.toLowerCase();console.log(str); //Hello Worldconsole.log(str1); //hello world</code></pre></li><li><p><strong>toUpperCase(): 把字符串转为大写，返回新的字符串。</strong></p><pre><code>var str=&quot;hello world&quot;;var str1=str.toUpperCase();console.log(str); //hello worldconsole.log(str1); //HELLO WORLD</code></pre></li><li><p><strong>charAt(): 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。</strong></p><pre><code>var str=&quot;hello world&quot;;var str1=str.charAt(6);console.log(str1); //w</code></pre></li><li><p><strong>charCodeAt(): 返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。如果index不在0-str.length(不包含str.length)之间，返回NaN。</strong></p><pre><code>var str=&quot;hello world&quot;;var str1=str.charCodeAt(1);var str2=str.charCodeAt(-2); //NaNconsole.log(str1); //101</code></pre></li><li><p><strong>indexOf(): 返回某个指定的子字符串在字符串中第一次出现的位置，indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。</strong></p><pre><code>var str=&quot;Hello World&quot;;var str1=str.indexOf(&quot;o&quot;);var str2=str.indexOf(&quot;world&quot;);var str3=str.indexOf(&quot;o&quot;, 5);console.log(str1); //4 默认只找第一个关键字位置，从下标0开始查找console.log(str2); //-1 没有找到console.log(str3); //7</code></pre></li><li><p><strong>lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。</strong></p><pre><code>var str=&quot;Hello World&quot;;var str1=str.lastIndexOf(&quot;o&quot;);var str2=str.lastIndexOf(&quot;world&quot;);var str3=str.lastIndexOf(&quot;o&quot;, 6);console.log(str1); //7console.log(str2); //-1console.log(str3); //4</code></pre></li><li><p><strong>slice(): 返回字符串中提取的子字符串。</strong></p><pre><code>var str=&quot;Hello World&quot;;var str1=str.slice(2); //如果只有一个参数，则提取开始下标到结尾处的所有字符串var str2=str.slice(2,7); //两个参数，提取下标为2，到下标为7但不包含下标为7的字符串var str3=str.slice(-7,-2); //如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串console.log(str1); //llo Worldconsole.log(str2); //llo Wconsole.log(str3); //o Wor</code></pre></li><li><p><strong>substring(): 提取字符串中介于两个指定下标之间的字符。</strong></p><pre><code>var str=&quot;Hello World&quot;;var str1=str.substring(2); //如果只有一个参数，则提取开始下标到结尾处的所有字符串var str2=str.substring(2,2);var str3=str.substring(2,7);//两个参数，提取下标为2，到下标为7但不包含下标为7的字符串console.log(str1); //llo Worldconsole.log(str2); //如果两个参数相等，返回长度为0的空串console.log(str3); //llo W</code></pre></li><li><p><strong>substr(): 返回从指定下标开始指定长度的的子字符串</strong></p><pre><code>var str=&quot;Hello World&quot;;var str1=str.substr(1)var str2=str.substr(1,3);var str3=str.substr(-3,2);console.log(str1); //ello World console.log(str2); //ellconsole.log(str3); //rl</code></pre></li><li><p><strong>split(): 把字符串分割成字符串数组。</strong></p><pre><code>var str=&quot;AA BB CC DD&quot;;var string1=&quot;1:2:3:4:5&quot;;var str1=str.split(&quot;&quot;);//如果把空字符串 (&quot;&quot;)用作分割符，那么字符串的每个字符之间都会被分割var str2=str.split(&quot; &quot;); //以空格为分隔符var str3=str.split(&quot;&quot;,4); //4指定返回数组的最大长度var str4=string1.split(&quot;:&quot;);console.log(str1); // [&quot;A&quot;, &quot;A&quot;, &quot; &quot;, &quot;B&quot;, &quot;B&quot;, &quot; &quot;, &quot;C&quot;, &quot;C&quot;, &quot; &quot;, &quot;D&quot;, &quot;D&quot;]console.log(str2); //[&quot;AA&quot; &quot;BB&quot; &quot;CC&quot; &quot;DD&quot;]console.log(str3); //[&quot;A&quot;, &quot;A&quot;, &quot; &quot;, &quot;B&quot;]console.log(str4); // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</code></pre></li><li><p><strong>replace(): 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</strong></p><pre><code>var str=&quot;hello WORLD&quot;;var reg=/o/ig; //o为要替换的关键字，不能加引号，否则替换不生效，i忽略大小写，g表示全局查找。var str1=str.replace(reg,&quot;**&quot;)console.log(str1); //hell** W**RLD</code></pre></li><li><p><strong>match(): 返回所有查找的关键字内容的数组</strong></p><pre><code>var str=&quot;To be or not to be&quot;;var reg=/to/ig;var str1=str.match(reg);console.log(str1); //[&quot;To&quot;, &quot;to&quot;]console.log(str.match(&quot;Hello&quot;)); //null</code></pre></li><li><p><strong>repeat()方法返回一个新字符串，表示将原字符串重复n次。</strong></p><pre><code>&#39;x&#39;.repeat(3) // &quot;xxx&quot;&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;&#39;na&#39;.repeat(0) // &quot;&quot;</code></pre></li><li><p><strong>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</strong></p><pre><code>&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;</code></pre><blockquote><p><strong>padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。如果省略第二个参数，默认使用空格补全长度。</strong></p></blockquote></li><li><p><strong>ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</strong></p><pre><code>const s = &#39;  abc  &#39;;s.trim() // &quot;abc&quot; 去除前后所有的空格s.trimStart() // &quot;abc  &quot; s.trimEnd() // &quot;  abc&quot;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>watch-computed-methods之间的对比</title>
      <link href="/2020/04/07/san-da-ji-suan-bi-jiao/"/>
      <url>/2020/04/07/san-da-ji-suan-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><ol><li><strong>computed属性结果会被缓存,除非依赖的响应式属性发生变化才会重新计算,主要当作属性来使用</strong><pre><code>//这意味着下面的计算属性将不再更新，因为Date.now()不是响应式依赖：computed:{  nowTime(){   return Date.now();}}</code></pre></li><li><strong>顾名思义,计算属性一般用于属性的计算,有些属性需要一定计算后才能展示给客户看，这个时候就需要用的computed就可以很好的解决</strong><pre><code>&lt;div id=&quot;example&quot;&gt;{{ message.split('').reverse().join('') }}&lt;/div&gt;</code></pre><blockquote><p><strong>如果不用计算属性，那么就如上面一样用mastuach语法会让结构看来臃肿不够清晰</strong></p></blockquote><pre><code> &lt;div id=&quot;example&quot;&gt;   {{ reversedMessage }} &lt;/div&gt; //如果需要详细看reversedMessage只需去computed里面看它的具体实现即可 var vm = new Vue({   el: &#39;#example&#39;,   data: {     message: &#39;Hello&#39;   },   computed: {     reversedMessage: function () {       return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;);     }   } })</code></pre></li><li><strong>计算属性默认时getter方法,如果你需要也可以给该计算属性设置一个setter方法</strong><pre><code>computed: {  fullMessage:{    //getter    get(){      return this.message + &#39;-&#39; + &#39;Smile&#39;;    }    //setter    set(newValue){      this.message = newValue;    }  }   }</code></pre></li></ol><h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><ol><li><strong>methods方法代表一个具体的操作，主要用以书写业务逻辑</strong></li><li><strong>methods和computed最大的差别就在于methods不会缓存,所以如果用methods代替computed的话，那么调用了多少次就执行了多少次，那么可想而知性能是多大的浪费</strong><pre><code>//下面假设已经有了计算属性和方法，返回的结果都完全一样，但是计算属性在没有改变//响应式属性时只会调用一次，而方法调用了多少次就执行了多少次&lt;div id=&quot;example&quot;&gt;  {{ reversedMessage }} //计算属性  {{ reversedMessage }} //计算属性  {{ reversedMessage }} //计算属性  {{ methodMessage }} //methods  {{ methodMessage }} //methods  {{ methodMessage }} //methods&lt;/div&gt;</code></pre></li></ol><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><ol><li><strong>虽然计算属性在大多数情况下更合适，但有时候也需要一个自定义的watcher。这是为什么Vue通过watch选项提供一个更通用的方法，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的</strong></li><li><strong>主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑；可以看作时<code>computed</code>和<code>methods</code>的结合体</strong><pre><code>&lt;template&gt;&lt;div&gt;  &lt;p&gt;obj.a: {{obj.a}}&lt;/p&gt;  &lt;p&gt;obj.a: &lt;input type=&quot;text&quot; v-model=&quot;obj.a&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &#39;index&#39;,  data(){      return{          obj:{              a:&#39;初始值&#39;          }      }  },  watch: {      obj: {          handler(newVal, objVal) {             // if(newVal.obj || objVal.obj != objVal.obj){              //    console.log(22);    //控制台并没有打印   监测为对象的时候，newVal == oldVal        //      }                    console.log(33)    //打印为33          },          deep:true      }  }}&lt;/script&gt;</code></pre><blockquote><p><strong>对象和数组都是引用类型，引用类型变量存的是地址，地址没有变，所以不会触发watch。这时我们需要进行深度监听，就需要加上一个属性 deep，值为 true</strong></p></blockquote></li></ol><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><ol><li><strong>watch用于观察和监听页面上的vue实例，当你需要在数据变化响应时，执行异步操作，或高性能消耗的操作，那么watch为最佳选择。</strong></li><li><strong>computed可以关联多个实时计算的对象，当这些对象中的其中一个改变时都会触发这个属性具有缓存能力，所以只有当数据再次改变时才会重新渲染，否则就会直接拿取缓存中的数据.</strong></li><li><strong>methods方法表示一个具体的操作，主要书写业务逻辑。</strong><br>以上纯属个人理解，有更好的建议可以下面评论或者给我留言，我会努力的改进的哟!</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue的组件化开发</title>
      <link href="/2020/04/05/vue-zu-jian-hua/"/>
      <url>/2020/04/05/vue-zu-jian-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="vue的组件化"><a href="#vue的组件化" class="headerlink" title="vue的组件化"></a>vue的组件化</h2><blockquote><p>组件化是Vue的精髓，Vue就是由一个一个的组件构成的,形成一颗庞大的组件树。Vue的组件化设计到的内容又非常多，因此在这里阐述一下个人对Vue的组件化的理解。</p></blockquote><h2 id="组件的分类"><a href="#组件的分类" class="headerlink" title="组件的分类"></a>组件的分类</h2><ol><li><strong>完全公共组件和业务逻辑完全不相关的组件</strong></li><li><strong>和业务逻辑相关但多页面可以多次复用的组件</strong></li><li><strong>只和每个页面相关的子组件</strong></li></ol><blockquote><p>上面三种类型我个人喜欢抽出三个文件夹来存放</p></blockquote><h2 id="组件化和模块化的区别"><a href="#组件化和模块化的区别" class="headerlink" title="组件化和模块化的区别"></a>组件化和模块化的区别</h2><ol><li><strong>组件化：是从UI界面进行划分的——前端的组件化可以方便 UI界面的复用</strong></li><li><strong>模块化：是从代码逻辑的角度进行划分的——方便后台代码的分层开发，保证每个功能模块的职能单一。</strong></li></ol><h2 id="组件化的具体实例"><a href="#组件化的具体实例" class="headerlink" title="组件化的具体实例:"></a>组件化的具体实例:</h2><pre><code>&lt;template&gt;  &lt;div class=&quot;nav-bar&quot;&gt;    &lt;div class=&quot;left&quot;&gt;&lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt;&lt;/div&gt;    &lt;div class=&quot;center&quot;&gt;&lt;slot name=&quot;center&quot;&gt;&lt;/slot&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &quot;NavBar&quot;  }&lt;/script&gt;&lt;style scoped&gt;  .nav-bar {    display: flex;    height: 44px;    line-height: 44px;    text-align: center;    box-shadow: 0 1px 1px rgba(100,100,100,.1);  }  .left, .right {    width: 60px;  }  .center {    flex: 1;  }&lt;/style&gt;</code></pre><blockquote><p><strong>如上面代码是我个人封装的一个navBar，头部导航条，在很多项目中都是用的上的,这就属性和业务逻辑完全不相关的组件，很多页面都用的上，一份代码多次复用，这也是我认为组件化最大的特点，复用性!</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><blockquote><p><strong>模块之间需要考虑，模块之间页面跳转、数据传递、初始化处理。组件化是工程分为各个模块，各个模块之间相互解耦，独立起来可编译调试，合成一个工程需要协作、同步。以上纯属个人理解，有更好的建议可以下面评论或者给我留言，我会努力的改进的哟!</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue的生命周期</title>
      <link href="/2020/04/03/vue-zhong-de-sheng-ming-zhou-qi/"/>
      <url>/2020/04/03/vue-zhong-de-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<p> <strong>首先，每个Vue实例在被创建之前都要经过一系列的初始化到销毁的过程,这个过程就是vue的生命周期。直接上一张官网的图:</strong><br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1585920841526&di=bf9f32b9c44984d8a05c128859c7a410&imgtype=0&src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F213%2Ff8341462947cd6c3e04e0bdbb324b2e5.png" alt="vue"><br> <strong>多的我也不再赘述我就直接说说我对每个阶段的钩子函数的理解,全部的钩子函数我先列出就和我列出的排列顺序一样，这也其实是它们的执行时机:</strong></p><ul><li><strong>beforeCreate</strong></li><li><strong>created</strong></li><li><strong>beforeMount</strong></li><li><strong>mounted</strong></li><li><strong>beforeUpdate</strong></li><li><strong>updated</strong></li><li><strong>beforeDestroy</strong></li><li><strong>destroyed</strong></li></ul><ol><li><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a><strong>beforeCreate</strong></h3><blockquote><p><strong>实例组件刚创建，元素DOM和数据都还没有初始化，data和mthods里面的数据在这个钩子函数里都拿不到。</strong></p></blockquote></li><li><h3 id="created"><a href="#created" class="headerlink" title="created"></a><strong>created</strong></h3><blockquote><p><strong>数据data已经初始化完成，mthonds也已经可以调用，但是DOM未挂载到页面上。在这里不能进行dom元素的操作，除非利用vm.$nextTick()这个方法是可以等页面中dom全部挂载到页面上就会回调的一个方法，里面就可以进行对dom元素的操作,如果想在created里面操作dom一定记得加钩子函数.</strong></p></blockquote></li><li><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a><strong>beforeMount</strong></h3><blockquote><p><strong>此时已经完成虚拟dom的加载也就是在内存中已经有了虚拟dom树，数据也初始化完成，但是尚未把模板渲染到页面中</strong></p></blockquote></li><li><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a><strong>mounted</strong></h3><blockquote><p><strong>此时已经完成了dom的挂载和渲染这里面已经可以对dom进行操作了，所以一般对dom操作的步骤都应当写在这个钩子函数里面，但是我个人实践发现不管在哪里操作dom只要我操作的这个dom里面有关图片的加载就容易出问题，应为图片的加载比较特俗，一般我想拿到精确的数据我会等图片加载完回调一个图片load事件就可以解决了</strong></p></blockquote></li><li><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a><strong>beforeUpdate</strong></h3><blockquote><p><strong>只要是页面数据改变了都会触发,data里面想更改的数据已经改变了，但是如果页面一直在调用这个数据此时并不会触发vue的响应式，所以页面呈现的还是老的数据，页面上的数据还是旧的。页面尚未和数据同步更新</strong></p></blockquote></li><li><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a><strong>updated</strong></h3><blockquote><p><strong>只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。这里和beforeupdate里面相差的就是这里已经完成了页面的数据和 model数据的同步</strong></p></blockquote></li><li><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a><strong>beforeDestroy</strong></h3><blockquote><p><strong>执行这个钩子函数的时候vue实例就已经从运行阶段进入到销毁阶段，实例身上所有的data和所有的methods以及filter，指令…..都处于可用状态，意义上其实还没有真正执行销毁的过程</strong></p></blockquote></li><li><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a><strong>destroyed</strong></h3><blockquote><p><strong>当执行到这里的时候，实例身上的所有的方法 指令 数据…都已经不可以调用,此时vue实例已经完全销毁了</strong></p></blockquote><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p><strong>vue生命周期是非常重要的，其中created和mounted是本人经常使用到的两个钩子函数，每个钩子函数执行的时机都不一样，需要认真考虑它们执行的时机及运用，在不同的业务逻辑下运用不同的钩子函数，以上纯属个人理解，有更好的建议可以下面评论或者给我留言，我会努力的改进的哟!</strong></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于js的预解析</title>
      <link href="/2020/04/02/js-zhong-de-yu-jie-xi/"/>
      <url>/2020/04/02/js-zhong-de-yu-jie-xi/</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="js代码为什么会被预解析"><a href="#js代码为什么会被预解析" class="headerlink" title="js代码为什么会被预解析"></a>js代码为什么会被预解析</h2><ol><li><strong>js代码通过浏览器的 js 解释器（js 引擎） 来执行的</strong></li><li><strong>js 解释器 来执行js 代码分为两步： 首先预解析 再 代码执行</strong></li></ol></li><li><h2 id="预解析的步骤"><a href="#预解析的步骤" class="headerlink" title="预解析的步骤"></a>预解析的步骤</h2><ol><li><strong>首先把函数声明和变量声明，提升到当前作用域最前面。（原因，是因为JS是一个解释执行的脚本语言，从上到下执行。如果函数调用出现在函数定义之前，就会导致失败。）</strong></li><li><strong>变量提升的是声明并不赋值， 函数 只提升声明 并不调用</strong></li><li><strong>变量提升也好函数提升也好都是在自己所处的当前作用域下进行提升</strong></li></ol></li><li><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h2><ol><li><strong>测试1：</strong><pre><code>//测试1function demo1(){console.log(a); var a = 5;}var a = 10;demo1(); //undefined</code></pre></li></ol><strong>最后打印的结果是undefined，这就是js的预解析机制，它并不会去找全局变量a = 10；而是在demo1函数中在当前的函数作用域中提升了变量，也就是预解析机制;</strong><pre><code>//和测试1等价var a;function demo1(){  var a;  console.log(a);   a = 5;} a = 10; demo1(); //undefined</code></pre><ol start="2"><li><strong>测试2：</strong><pre><code>b(); //此时b为变量 //测试2var b = function demo2(){console.log(&#39;demo2&#39;);}</code></pre></li></ol><strong>最后打印的结果是b is not function，这里因为此处的b是函数表达式，被当成变量提升而不是函数声明提升，所以b（）调用这个方法在完成赋值之前是被js解析成一个变量，变量怎么可以被当成方法来调用呢？如果b（）在完成赋值之后那么就会打印demo2如下图代码</strong><pre><code>  //测试2var b = function demo2(){  console.log(&#39;demo2&#39;);}  b(); //此时b为函数</code></pre><ol start="3"><li><strong>测试3：</strong><pre><code>b(); //此时b为函数//测试3var b = 5;function b(){console.log(&#39;demo3&#39;);}</code></pre></li></ol><strong>最后打印的结果是demo3，这里调用b的时候js是把b解析成了下面的函数b，那么疑惑来了函数名和变量名相同，怎么才能确定b到底是变量还是方法呢？我的理解是看b在哪个时候调用，如果b在被赋值之前调用同名的变量和方法那么调用的就是方法，如果是在被赋值之后调用那就是取决你为b赋的值，在这里就是b = 5，代码如下</strong><pre><code>  //测试3  var b = 5;function b(){  console.log(&#39;demo3&#39;);}  b(); //b is not a function   console.log(b); // 当然真实运行的时候不能有上面那条代码不然直接报错卡死在上一条代码也就/不会执行到这里，这里的b是当作了变量所以是可以正常打印的，结果是5</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><blockquote><p><strong>js的预解析机制，个人理解就是搞清除被预解析的变量和函数分别是在哪个作用域下，这个一定得分清，还有就是变量和函数同名  调用的到底是什么，这个得看代码的执行时机了。以上纯属个人理解，有更好的建议可以下面评论或者给我留言，我会努力的改进的哟!</strong></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外边距塌陷</title>
      <link href="/2020/04/02/wai-bian-ju-ta-xian/"/>
      <url>/2020/04/02/wai-bian-ju-ta-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="造成外边距塌陷的原因"><a href="#造成外边距塌陷的原因" class="headerlink" title="造成外边距塌陷的原因"></a>造成外边距塌陷的原因</h1><hr><p><strong>根据规范，一个盒子如果使处于普通文档流中而且没有垂直方向补白和垂直方向边框的话，那么它的上边距会和它的文档流中的第一个子元素的上边距重叠。意思就是子元素的margin-top如果找不到父元素的border或者padding，就会与父元素的上边距重叠。左右marggin不会发生外边距合并的现象</strong></p><hr><h1 id="外边距塌陷的代码"><a href="#外边距塌陷的代码" class="headerlink" title="外边距塌陷的代码:"></a>外边距塌陷的代码:</h1><pre><code>  &lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;children&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 样式部分 --&gt;.father {            width: 500px;            height: 200px;            margin-top: 10px;            background-color: green;        }.children {            margin-top: 20px;            background-color: red;        }</code></pre><p><strong>上述代码运行以后childern的外边距按理说应该是30px，但是实际上却是20px,这就是典型垂直方向上的外边距合并,那么要怎么解决这种状况呢</strong></p><h2 id="我知道的解决方法有这五种"><a href="#我知道的解决方法有这五种" class="headerlink" title="我知道的解决方法有这五种"></a>我知道的解决方法有这五种</h2><ol><li><strong>给父元素father 加上overflow：hidden属性</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         overflow: hidden; //添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre></li><li><strong>给父元素father 加上垂直方向的padding：value</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         padding-top: 5px; //添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre></li><li><strong>给父元素father 加上垂直方向的border</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         border: 1px solid transparent; //添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre></li><li><strong>给父元素father 加上float</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         float:left //这里只要不为none即可,添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre></li><li><strong>给父元素father 加上position:absolute</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         position:absolute //添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p><strong>外边距塌陷是很容易发生的，刚开始我遇到的时候也是非常的抓狂，margin发生了不在预料之中的状况，一定要稳住心态，踩过的坑越多，成长的才会更快!一起加油，少年！以上纯属个人理解，有更好的建议可以下面评论或者给我留言，我会努力的改进的哟!</strong></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 页面 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
