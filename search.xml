<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于js的预解析</title>
      <link href="/2020/04/02/js-zhong-de-yu-jie-xi/"/>
      <url>/2020/04/02/js-zhong-de-yu-jie-xi/</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="js代码为什么会被预解析"><a href="#js代码为什么会被预解析" class="headerlink" title="js代码为什么会被预解析"></a>js代码为什么会被预解析</h2><ol><li><strong>js代码通过浏览器的 js 解释器（js 引擎） 来执行的</strong></li><li><strong>js 解释器 来执行js 代码分为两步： 首先预解析 再 代码执行</strong></li></ol></li><li><h2 id="预解析的步骤"><a href="#预解析的步骤" class="headerlink" title="预解析的步骤"></a>预解析的步骤</h2><ol><li><strong>首先把函数声明和变量声明，提升到当前作用域最前面。（原因，是因为JS是一个解释执行的脚本语言，从上到下执行。如果函数调用出现在函数定义之前，就会导致失败。）</strong></li><li><strong>变量提升的是声明并不赋值， 函数 只提升声明 并不调用</strong></li><li><strong>变量提升也好函数提升也好都是在自己所处的当前作用域下进行提升</strong></li></ol></li><li><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h2><ol><li><strong>测试1：</strong><pre><code>//测试1function demo1(){console.log(a); var a = 5;}var a = 10;demo1(); //undefined</code></pre></li></ol><strong>最后打印的结果是undefined，这就是js的预解析机制，它并不会去找全局变量a = 10；而是在demo1函数中在当前的函数作用域中提升了变量，也就是预解析机制;</strong><pre><code>//和测试1等价var a;function demo1(){  var a;  console.log(a);   a = 5;} a = 10; demo1(); //undefined</code></pre><ol start="2"><li><strong>测试2：</strong><pre><code>b(); //此时b为变量 //测试2var b = function demo2(){console.log(&#39;demo2&#39;);}</code></pre></li></ol><strong>最后打印的结果是b is not function，这里因为此处的b是函数表达式，被当成变量提升而不是函数声明提升，所以b（）调用这个方法在完成赋值之前是被js解析成一个变量，变量怎么可以被当成方法来调用呢？如果b（）在完成赋值之后那么就会打印demo2如下图代码</strong><pre><code>  //测试2var b = function demo2(){  console.log(&#39;demo2&#39;);}  b(); //此时b为函数</code></pre><ol start="3"><li><strong>测试3：</strong><pre><code>b(); //此时b为函数//测试3var b = 5;function b(){console.log(&#39;demo3&#39;);}</code></pre></li></ol><strong>最后打印的结果是demo3，这里调用b的时候js是把b解析成了下面的函数b，那么疑惑来了函数名和变量名相同，怎么才能确定b到底是变量还是方法呢？我的理解是看b在哪个时候调用，如果b在被赋值之前调用同名的变量和方法那么调用的就是方法，如果是在被赋值之后调用那就是取决你为b赋的值，在这里就是b = 5，代码如下</strong><pre><code>  //测试3  var b = 5;function b(){  console.log(&#39;demo3&#39;);}  b(); //b is not a function   console.log(b); // 当然真实运行的时候不能有上面那条代码不然直接报错卡死在上一条代码也就/不会执行到这里，这里的b是当作了变量所以是可以正常打印的，结果是5</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><blockquote><p><strong>js的预解析机制，个人理解就是搞清除被预解析的变量和函数分别是在哪个作用域下，这个一定得分清，还有就是变量和函数同名  调用的到底是什么，这个得看代码的执行时机了。以上纯属个人理解，有更好的建议可以下面评论或者给我留言，我会努力的改进的哟!</strong></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外边距塌陷</title>
      <link href="/2020/04/02/wai-bian-ju-ta-xian/"/>
      <url>/2020/04/02/wai-bian-ju-ta-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="造成外边距塌陷的原因"><a href="#造成外边距塌陷的原因" class="headerlink" title="造成外边距塌陷的原因"></a>造成外边距塌陷的原因</h1><hr><p><strong>根据规范，一个盒子如果使处于普通文档流中而且没有垂直方向补白和垂直方向边框的话，那么它的上边距会和它的文档流中的第一个子元素的上边距重叠。意思就是子元素的margin-top如果找不到父元素的border或者padding，就会与父元素的上边距重叠。左右marggin不会发生外边距合并的现象</strong></p><hr><h1 id="外边距塌陷的代码"><a href="#外边距塌陷的代码" class="headerlink" title="外边距塌陷的代码:"></a>外边距塌陷的代码:</h1><pre><code>  &lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;children&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 样式部分 --&gt;.father {            width: 500px;            height: 200px;            margin-top: 10px;            background-color: green;        }.children {            margin-top: 20px;            background-color: red;        }</code></pre><p><strong>上述代码运行以后childern的外边距按理说应该是30px，但是实际上却是20px,这就是典型垂直方向上的外边距合并,那么要怎么解决这种状况呢</strong></p><h2 id="我知道的解决方法有这五种"><a href="#我知道的解决方法有这五种" class="headerlink" title="我知道的解决方法有这五种"></a>我知道的解决方法有这五种</h2><ol><li><strong>给父元素father 加上overflow：hidden属性</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         overflow: hidden; //添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre></li><li><strong>给父元素father 加上垂直方向的padding：value</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         padding-top: 5px; //添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre></li><li><strong>给父元素father 加上垂直方向的border</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         border: 1px solid transparent; //添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre></li><li><strong>给父元素father 加上float</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         float:left //这里只要不为none即可,添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre></li><li><strong>给父元素father 加上position:absolute</strong><pre><code>.father {         width: 500px;         height: 200px;         margin-top: 10px;         position:absolute //添加这个属性使父节点形成BFC模式         background-color: green;     }.children {         margin-top: 20px;         background-color: red;     }</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p><strong>外边距塌陷是很容易发生的，刚开始我遇到的时候也是非常的抓狂，margin发生了不在预料之中的状况，一定要稳住心态，踩过的坑越多，成长的才会更快!一起加油，少年！以上纯属个人理解，有更好的建议可以下面评论或者给我留言，我会努力的改进的哟!</strong></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
